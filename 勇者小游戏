#include <iostream>
#include <string>
#include <cstdlib> // 需要
#include <ctime>   // 需要
#include <iomanip> // 用于美化血条

// --- 使用标准命名空间 ---
// (你之前的代码在类中使用了 std::，但在 main 中没有，
//  为了统一，我们在这里声明)
using namespace std;

// --- ANSI 颜色代码 ---
#define RESET   "\033[0m"
#define GREEN   "\033[32m" // 英雄
#define RED     "\033[31m" // 哥布林
#define YELLOW  "\033[33m" // 状态
#define CYAN    "\033[36m" // 技能
#define MAGENTA "\033[35m" // 暴击

// --- 辅助函数：创建血条/蓝条 ---
string create_bar(int current, int max, int length = 20) {
    if (current < 0) current = 0;
    float percent = (float)current / max;
    int fill = (int)(percent * length);
    string bar = "[";
    for (int i = 0; i < length; ++i) {
        bar += (i < fill) ? "|" : "-";
    }
    bar += "]";
    return bar + " " + to_string(current) + "/" + to_string(max);
}


// --- “生物” (基类) ---
class Creature {
protected:
    string name;
    int health;
    int max_health; // 新增：最大生命值

public:
    // 修改：构造函数，保存最大生命值
    Creature(string n, int h) {
        name = n;
        health = h;
        max_health = h; // 记录初始生命值为最大值
    }

    // 修改：受伤函数，防止血量为负
    void take_damage(int damage) {
        health = health - damage;
        if (health < 0) {
            health = 0; // 血量不能低于 0
        }
        cout << "  " << name << " 受到了 " << damage << " 点伤害！" << " (HP: " << health << "/" << max_health << ")" << endl;
    }

    // 新增：治疗函数
    void heal(int amount) {
        health += amount;
        if (health > max_health) {
            health = max_health; // 治疗不能超过最大生命值
        }
        cout << "  " << name << " 恢复了 " << amount << " 点生命！" << " (HP: " << health << "/" << max_health << ")" << endl;
    }

    // === “Getter” 按钮 ===
    string get_name() {
        return name;
    }

    int get_health() {
        return health;
    }
    
    // 新增：检查是否存活
    bool is_alive() {
        return health > 0;
    }
};


// --- “玩家” (派生类) ---
class Player : public Creature {
private:
    int attack_power;
    int mp;         // 新增：法力值
    int max_mp;     // 新增：最大法力值

public:
    // 修改：构造函数，加入 MP
    Player(string n, int h, int m, int ap) : Creature(n, h) {
        mp = m;
        max_mp = m;
        attack_power = ap;
        cout << GREEN << "英雄 " << name << " (HP: " << health << ", MP: " << mp << ", 攻击: " << ap << ") 诞生了！" << RESET << endl;
    }

    // 修改：打印状态，显示 MP 和血条
    void print_status() {
        cout << YELLOW << "  " << left << setw(10) << name << " HP: " << create_bar(health, max_health) << RESET << endl;
        cout << YELLOW << "  " << left << setw(10) << " " << " MP: " << create_bar(mp, max_mp) << RESET << endl;
    }

    // 新增：普通攻击 (私有，由 show_action_menu 调用)
    void normal_attack(Creature& target) {
        cout << GREEN << name << " 挥剑攻击了 " << target.get_name() << "!" << RESET << endl;
        target.take_damage(attack_power);
    }
    
    // 新增：回合行动选择
    void show_action_menu(Creature& target) {
        int choice = 0;

        while (true) {
            cout << CYAN;
            cout << "\n请选择你的行动：\n";
            cout << "1. 普通攻击 (0 MP) - 造成 " << attack_power << " 伤害\n";
            cout << "2. [火球术] (15 MP) - 造成 " << (int)(attack_power * 1.8) << " 伤害\n";
            cout << "3. [强力斩] (20 MP) - 造成 " << (int)(attack_power * 2.5) << " 伤害\n";
            cout << "4. [圣光治愈] (25 MP) - 恢复 " << (int)(max_health * 0.4) << " HP\n";
            cout << "5. [奥术飞弹] (10 MP) - 造成 " << (int)(attack_power * 1.2) << " 伤害\n";
            cout << RESET << "输入选项 (1-5): ";
            
            cin >> choice;

            // 检查输入是否为数字
            if (cin.fail() || choice < 1 || choice > 5) {
                cin.clear(); // 清除错误状态
                cin.ignore(10000, '\n'); // 忽略无效输入
                cout << RED << "输入无效，请重新输入 1 到 5 之间的数字。\n" << RESET;
                continue;
            }
            cin.ignore(10000, '\n'); // 清除输入缓冲区中的换行符

            // --- 技能逻辑 ---
            switch (choice) {
                case 1: // 普通攻击
                    normal_attack(target);
                    return; // 结束回合

                case 2: // 火球术
                    if (mp >= 15) {
                        mp -= 15;
                        int damage = (int)(attack_power * 1.8);
                        cout << GREEN << name << " 释放了 [火球术]，消耗 15 MP！\n" << RESET;
                        target.take_damage(damage);
                        return;
                    } else {
                        cout << RED << "法力不足！\n" << RESET;
                        // 不 return，让玩家重新选择
                    }
                    break;
                
                case 3: // 强力斩
                    if (mp >= 20) {
                        mp -= 20;
                        int damage = (int)(attack_power * 2.5);
                        cout << GREEN << name << " 使出了 [强力斩]，消耗 20 MP！\n" << RESET;
                        target.take_damage(damage);
                        return;
                    } else {
                        cout << RED << "法力不足！\n" << RESET;
                    }
                    break;

                case 4: // 圣光治愈
                    if (mp >= 25) {
                        mp -= 25;
                        int heal_amount = (int)(max_health * 0.4);
                        cout << GREEN << name << " 吟唱了 [圣光治愈]，消耗 25 MP！\n" << RESET;
                        this->heal(heal_amount); // 治疗自己
                        return;
                    } else {
                        cout << RED << "法力不足！\n" << RESET;
                    }
                    break;

                case 5: // 奥术飞弹
                    if (mp >= 10) {
                        mp -= 10;
                        int damage = (int)(attack_power * 1.2);
                        cout << GREEN << name << " 射出了 [奥术飞弹]，消耗 10 MP！\n" << RESET;
                        target.take_damage(damage);
                        return;
                    } else {
                        cout << RED << "法力不足！\n" << RESET;
                    }
                    break;
            }
        }
    }

    // 新增：每回合回蓝
    void regenerate_mana() {
        if (!is_alive()) return; // 死了不回蓝
        int mana_regen = 5;
        mp += mana_regen;
        if (mp > max_mp) mp = max_mp;
        cout << "  " << name << " 恢复了 " << mana_regen << " 点法力。\n";
    }
};


// --- “怪物” (派生类) ---
class Monster : public Creature {
private:
    int attack_power; 

public:
    Monster(string n, int h, int ap) : Creature(n, h) {
        attack_power = ap;
        cout << RED << "一只 " << name << " (HP: " << health << ", 攻击: " << ap << ") 出现了！" << RESET << endl;
    }

    void print_status() {
        cout << YELLOW << "  " << left << setw(10) << name << " HP: " << create_bar(health, max_health) << RESET << endl;
    }

    // === 修改：怪物的“攻击”按钮，加入新机制 ===
    void attack(Creature& target) {
        // rand() % 100 会产生 0-99 的随机数
        int action_chance = rand() % 100; 
        int damage = 0;

        if (action_chance < 70) { // 70% 概率普通攻击
            damage = attack_power;
            cout << RED << name << " 猛击了 " << target.get_name() << "!" << RESET << endl;
            target.take_damage(damage);
        } else { // 30% 概率使用重击
            cout << RED << name << " 蓄力使出了 [重击]！\n" << RESET;
            
            int crit_chance = rand() % 100; // 再次骰点决定是否暴击
            if (crit_chance < 30) { // 30% 概率暴击
                damage = (int)(attack_power * 2.5); // 暴击伤害
                cout << MAGENTA << "  >> 致命一击 (CRITICAL HIT) !!" << RESET << endl;
            } else { // 70% 概率普通重击
                damage = (int)(attack_power * 1.5); // 重击伤害
            }
            target.take_damage(damage);
        }
    }
};


// --- “游戏管理员”开始工作 ---
int main() {
    // 初始化随机数种子，否则每次运行的"随机"结果都一样
    srand((unsigned int)time(NULL));

    // === 修改：创建英雄时，提供 HP, MP, 攻击力 ===
    Player hero("Joshua", 100, 50, 12);
    Monster goblin("哥布林", 80, 8);

    cout << "\n--- 战斗开始！ ---" << endl;

    // === 新增：战斗循环 ===
    // 只要双方都还活着，就继续战斗
    while (hero.is_alive() && goblin.is_alive()) {
        
        // --- 英雄的回合 (绿色) ---
        cout << GREEN << "\n=====================" << endl;
        cout << "    你的回合！" << endl;
        cout << "=====================" << RESET << endl;
        
        // 打印双方状态
        hero.print_status();
        goblin.print_status();

        hero.regenerate_mana(); // 英雄先回蓝
        hero.show_action_menu(goblin); // 英雄选择行动

        // 检查哥布林是否在英雄行动后死亡
        if (!goblin.is_alive()) {
            cout << YELLOW << "\n你击败了 " << goblin.get_name() << "!" << RESET << endl;
            break; // 跳出循环
        }

        // --- 哥布林的回合 (红色) ---
        cout << RED << "\n=====================" << endl;
        cout << "   " << goblin.get_name() << " 的回合！" << endl;
        cout << "=====================" << RESET << endl;
        
        // 打印双方状态 (哥布林行动前)
        hero.print_status();
        goblin.print_status();

        cout << "\n"; // 空一行
        goblin.attack(hero); // 哥布林发动攻击

        // 检查英雄是否在哥布林行动后死亡
        if (!hero.is_alive()) {
            cout << RED << "\n你被 " << goblin.get_name() << " 击败了..." << RESET << endl;
            break; // 跳出循环
        }

        cout << "\n(按回车键进入下一回合...)";
        cin.get(); // 暂停，等待玩家按键

    } // 循环结束

    // --- 战斗结束 ---
    cout << "\n--- 战斗结束 ---" << endl;
    if (hero.is_alive()) {
        cout << GREEN << "恭喜你获得了胜利！" << RESET << endl;
    } else {
        cout << RED << "游戏结束。" << RESET << endl;
    }

    cout << "\n按回车键退出...";
    cin.get();
    
    return 0;
}
